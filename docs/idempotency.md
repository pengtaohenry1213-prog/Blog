后端通用幂等键的典型实现流程
- 客户端生成幂等键（如 UUID），随请求在 header 或 body 传给后端。
- 服务端基于该键构造缓存键（如 `idem:{userId}:{idempotencyKey}`）并尝试原子写入：  
  - 使用 Redis `SET key value NX PX ttl`（或 SETNX + EXPIRE）原子占位；value 可存状态与结果定位信息。  
  - 写入成功：说明第一次处理，继续执行业务，并在成功后更新 value（如存业务结果标识），保持 ttl 覆盖请求重试窗口。  
  - 写入失败：说明已有同键请求。读取 value：  
    - 若状态为「处理中」，直接返回「请稍后重试」或轮询结果。  
    - 若状态为「成功」并有结果标识，则直接返回已产出的结果或其定位信息。  
    - 若状态为「失败」且允许重试，则清理/续期后再尝试；否则直接返回错误。
- 清理策略：ttl 要覆盖客户端重试时间；对已落库且需要长期可查的可在持久层做去重校验。

关于 `idem:{userId}:{idempotencyKey}` 在同一用户多 tab 的冲突
- 如果多个 tab 复用同一个 `idempotencyKey`，会被视为同一请求：后面的请求会命中已有键，得到「处理中/已成功」的响应，业务不会重复执行。  
- 如果每个 tab 产生不同的 `idempotencyKey`（推荐每次提交都新建 UUID），则不会冲突，各自独立执行。  
- 若担心用户在多 tab 里误复用同一个键（如缓存了表单数据），可以：  
  - 在前端每次提交强制生成新 UUID；  
  - 或在 key 中加入更细粒度维度（如表单实例/草稿 id、tab 随机 token），保证并行提交的键唯一；  
  - 同时在后端设置合理 ttl 和状态字段，避免长时间锁死。
- 